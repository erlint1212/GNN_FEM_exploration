import unittest
from unittest.mock import patch, MagicMock
import torch
import numpy as np
import dolfin
import os
import shutil

# Assuming simp_burgers_r_adapt.py is in GAT_r_adaptivity folder
# We need to import specific functions or classes that are testable.
# The main script logic (__name__ == "__main__") is not directly unit tested.
from GAT_r_adaptivity.simp_burgers_r_adapt import get_monitor_function, dummy_classical_r_adaptivity, generate_dataset
from GAT_r_adaptivity.models.GAT import RAdaptGAT # Imported by simp_burgers_r_adapt

class TestSimpBurgersRAdapt(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.test_output_dir = "test_sbra_outputs" # sbra for simp_burgers_r_adapt
        if os.path.exists(cls.test_output_dir):
            shutil.rmtree(cls.test_output_dir)
        os.makedirs(cls.test_output_dir, exist_ok=True)
        
        # Override the OUTPUT_DIR in the simp_burgers_r_adapt module for tests
        # This is a bit tricky as it's a global in the script.
        # If the script is imported, its globals are set.
        # It's better if such configurations are passed or managed differently.
        # For now, we assume plots generated by tested functions go to their own output args.
        cls.original_sbra_output_dir = None
        if hasattr(sim_module, 'OUTPUT_DIR'): # sim_module is simp_burgers_r_adapt aliased
            cls.original_sbra_output_dir = sim_module.OUTPUT_DIR
            sim_module.OUTPUT_DIR = cls.test_output_dir


    @classmethod
    def tearDownClass(cls):
        if os.path.exists(cls.test_output_dir):
            shutil.rmtree(cls.test_output_dir)
        if cls.original_sbra_output_dir and hasattr(sim_module, 'OUTPUT_DIR'):
            sim_module.OUTPUT_DIR = cls.original_sbra_output_dir


    def test_get_monitor_function(self):
        coords = np.array([[0.1, 0.1], [0.5, 0.5], [0.9, 0.9]])
        monitor_values = get_monitor_function(coords)
        self.assertEqual(monitor_values.shape, (3,))
        self.assertTrue(np.all(monitor_values >= 0) and np.all(monitor_values <= 1))
        # Check if values are higher near the feature_center [0.75, 0.75]
        # coords[2] is closest to [0.75,0.75], so monitor_values[2] should be high
        # coords[0] is furthest, so monitor_values[0] should be low
        self.assertGreater(monitor_values[2], monitor_values[1])
        self.assertGreater(monitor_values[1], monitor_values[0])


    def test_dummy_classical_r_adaptivity(self):
        try:
            mesh = dolfin.UnitSquareMesh(3, 3)
            initial_coords = np.copy(mesh.coordinates())
            monitor_values = get_monitor_function(initial_coords)
            
            strength = 0.1
            new_coords = dummy_classical_r_adaptivity(mesh, monitor_values, strength=strength)
            
            self.assertEqual(new_coords.shape, initial_coords.shape)
            self.assertTrue(np.all(new_coords >= 0) and np.all(new_coords <= 1.00001)) # Allow for small floating point issues
            
            # Check if coordinates have moved (unless strength is 0 or monitor is flat)
            if strength > 0 and not np.allclose(monitor_values, monitor_values[0]):
                 self.assertFalse(np.allclose(new_coords, initial_coords))

        except Exception as e: # Catch dolfin/FEniCS specific errors if environment is not set up
            if "DOLFIN" in str(e) or "dolfin" in str(e):
                print(f"Skipping FEniCS dependent test_dummy_classical_r_adaptivity due to FEniCS error: {e}")
            else:
                raise e
                
    @patch('GAT_r_adaptivity.simp_burgers_r_adapt.fenics_mesh_to_pyg_data')
    @patch('GAT_r_adaptivity.simp_burgers_r_adapt.plot_funcs') # Mock the whole plot_funcs module
    def test_generate_dataset(self, mock_plot_funcs, mock_fenics_to_pyg):
        try:
            # Configure mock_fenics_to_pyg to return a mock Data object
            mock_pyg_data = MagicMock(spec=torch_geometric.data.Data)
            mock_pyg_data.x = torch.randn(4, 2) # Example: 2x2 mesh -> 4 nodes, 2 features
            mock_pyg_data.y = torch.randn(4, 2)
            mock_pyg_data.classical_time = 0.1
            mock_pyg_data.to.return_value = mock_pyg_data # for .to(DEVICE) calls
            mock_fenics_to_pyg.return_value = mock_pyg_data

            num_samples = 2
            # Temporarily override MESH_SIZE_MAX in the module if it's too large for tests
            # This is tricky; ideally, these are configurable.
            with patch('GAT_r_adaptivity.simp_burgers_r_adapt.MESH_SIZE_MAX', 5), \
                 patch('GAT_r_adaptivity.simp_burgers_r_adapt.MESH_SIZE_MIN', 5): # Force small meshes
                dataset, classical_times = generate_dataset(num_samples, plot_first_sample_density=True)

            self.assertEqual(len(dataset), num_samples)
            self.assertEqual(len(classical_times), num_samples)
            self.assertIsInstance(dataset[0], MagicMock) # Since fenics_mesh_to_pyg_data is mocked
            self.assertTrue(hasattr(dataset[0], 'y'))
            self.assertTrue(hasattr(dataset[0], 'classical_time'))

            # Check if plotting was called for the first sample
            if num_samples > 0:
                 mock_plot_funcs.density_plot_matrix.assert_any_call(unittest.mock.ANY, output=sim_module.OUTPUT_DIR, title=unittest.mock.ANY, show=False)

        except Exception as e:
             if "DOLFIN" in str(e) or "dolfin" in str(e):
                 print(f"Skipping FEniCS dependent test_generate_dataset due to FEniCS error: {e}")
             else:
                 raise e


    # To test the main script part, one would typically use integration tests
    # or refactor the main part into functions.
    # For unit tests, we focus on the helper functions as done above.
    # A simple test to ensure the script can be imported without immediate error:
    def test_script_importable(self):
        try:
            from GAT_r_adaptivity import simp_burgers_r_adapt
            self.assertIsNotNone(simp_burgers_r_adapt)
        except ImportError as e:
            self.fail(f"Failed to import simp_burgers_r_adapt: {e}")
        except Exception as e: # Catch dolfin/FEniCS specific errors if environment is not set up
            if "DOLFIN" in str(e) or "dolfin" in str(e):
                print(f"Skipping FEniCS dependent test_script_importable due to FEniCS error: {e}")
            else:
                self.fail(f"Importing simp_burgers_r_adapt raised an unexpected error: {e}")


# It's important that simp_burgers_r_adapt.py can be imported without
# running the full script automatically. The `if __name__ == '__main__':` guard is crucial.
# Need to alias the module for setUpClass/tearDownClass patching of globals
try:
    from GAT_r_adaptivity import simp_burgers_r_adapt as sim_module
    import torch_geometric # for MagicMock spec
except ImportError as e:
    sim_module = None # Handle if module itself or dependencies fail to import
    torch_geometric = None
    print(f"Warning: Could not import simp_burgers_r_adapt or torch_geometric for test setup: {e}")


if __name__ == '__main__':
    unittest.main()
